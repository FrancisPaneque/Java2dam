!SESSION 2023-10-27 17:28:05.444 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\Users\Francis\Desktop\Programación\workSpaceDam\.metadata\.bak_0.log
Created Time: 2023-10-27 17:29:24.722

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:24.722
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:24.724
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:26.683
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:29:26.685
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:29:26.686
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:30.697
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:30.698
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:30.699
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:31.857
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:31.858
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:31.859
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:33.280
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:33.281
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:33.282
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:35.084
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:35.085
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:35.086
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:37.460
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:37.462
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:37.462
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:39.615
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:39.616
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:39.617
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:39.633
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:29:39.635
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:39.701
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:39.702
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:39.703
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:40.640
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:40.642
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:40.642
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:42.420
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:29:42.421
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:29:42.423
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:44.587
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:44.588
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:44.589
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:45.902
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:45.903
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:45.904
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:46.877
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:46.878
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:46.879
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:47.788
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:47.789
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:47.790
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:50.015
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:50.016
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:50.017
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:53.262
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:53.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:53.264
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:54.705
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:54.706
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:54.707
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:58.799
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:29:58.800
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:29:58.801
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:58.840
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:58.842
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:58.843
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:00.983
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:30:00.984
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:30:00.985
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:03.287
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:03.288
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:03.289
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:03.406
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:03.407
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:03.408
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:05.402
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
}
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:30:05.403
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:30:05.404
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:05.433
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
}
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:05.435
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:05.436
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:06.537
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:30:06.538
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:30:06.539
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:06.615
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:06.617
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:06.618
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:08.407
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:08.408
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:08.409
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:09.887
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:09.888
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:09.889
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:10.994
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:10.995
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:10.995
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:20.691
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:20.693
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:20.693
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:20.707
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:30:20.708
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:21.957
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:21.959
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:21.960
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:24.065
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:30:24.066
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:30:24.067
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:24.087
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:24.088
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:24.089
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:24.108
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:30:24.109
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:24.871
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new AList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:30:24.872
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:30:24.873
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:24.922
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new AList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:24.923
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:24.924
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:25.827
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new List<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:30:25.828
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:30:25.828
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:25.872
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new List<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:25.873
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:25.874
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:27.232
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new List<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:27.233
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:27.234
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:32.190
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:30:32.192
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:30:32.192
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:32.212
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:32.213
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:32.214
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:30:33.529
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:30:33.531
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:30:33.532
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:34:48.565
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:34:48.566
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:34:48.567
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:34:49.873
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:34:49.874
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:34:49.875
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:34:57.471
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>();

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:34:57.472
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:34:57.473
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:34:57.534
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>();

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:34:57.536
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:34:57.536
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:34:58.158
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(dataToSend.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:34:58.159
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:34:58.159
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:34:58.249
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(dataToSend.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:34:58.250
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:34:58.251
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:00.622
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(dataToSend.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:00.623
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:00.624
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:00.636
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(dataToSend.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:35:00.637
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:01.437
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(dataToSen.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:35:01.438
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:35:01.439
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:01.456
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(dataToSen.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:01.457
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:01.458
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:03.132
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(d.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:35:03.133
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:35:03.134
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:03.200
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(d.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:03.201
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:03.202
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:03.722
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:35:03.724
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:35:03.724
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:03.826
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:03.827
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:03.828
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:05.738
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:05.739
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:05.740
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:07.971
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:07.973
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:07.973
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:20.299
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:20.300
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:20.301
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:20.313
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:35:20.314
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:20.386
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:20.387
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:20.388
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:22.262
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:22.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:22.263
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:22.275
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:35:22.276
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:22.346
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:22.348
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:22.348
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:25.810
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:25.811
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:25.811
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:43.704
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:35:43.705
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:35:43.706
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:35:44.446
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(.subList(startIndex, endIndex));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }

	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
  }
		
		
	
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
