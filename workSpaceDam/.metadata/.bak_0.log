!SESSION 2023-10-24 09:34:52.075 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

This is a continuation of log file C:\Users\Francis\Desktop\Programación\workSpaceDam\.metadata\.bak_1.log
Created Time: 2023-10-27 17:26:49.792

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:26:49.792
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:26:49.799
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:26:50.288
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcess));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:26:50.289
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:26:50.289
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:26:53.450
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcess));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:26:53.451
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:26:53.451
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:26:54.263
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:26:54.264
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:26:54.264
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1148)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:26:54.807
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:26:54.808
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:26:54.808
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:26:56.527
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:26:56.528
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:26:56.529
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:26:58.590
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:26:58.591
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:26:58.592
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:26:58.607
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:26:58.608
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:01.183
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:01.184
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:01.185
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:01.983
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:01.983
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:01.984
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:01.992
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:01.993
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:03.214
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:03.215
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:03.215
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:03.224
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:03.225
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:05.256
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:05.257
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:05.258
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:06.275
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:06.275
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:06.276
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:06.283
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:06.284
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:09.152
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:09.152
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:09.154
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:09.161
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:09.162
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:09.256
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:09.256
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:09.257
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:15.964
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:15.965
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:15.966
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:17.852
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:17.852
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:17.853
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:18.073
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:18.073
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:18.074
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:18.082
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:18.083
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:18.652
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:18.652
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:18.653
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:18.661
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:18.662
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:20.263
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:20.263
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:20.264
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:20.272
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:20.272
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:20.787
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:20.788
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:20.789
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:24.134
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:24.135
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:24.135
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:24.143
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:24.143
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:26.229
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:26.229
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:26.230
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:27.994
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:27.994
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:27.995
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:30.981
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:30.982
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:30.982
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:31.864
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:31.865
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:31.866
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:33.070
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:33.070
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:33.071
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:34.384
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:34.384
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:34.385
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:34.827
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:34.828
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:34.829
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:34.837
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:27:34.838
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:42.369
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:27:42.370
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:27:42.370
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:27:42.386
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:27:42.387
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:27:42.387
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:189)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-10-27 17:28:05.444 -----------------------------------------------
eclipse.buildId=4.27.0.20230309-1200
java.version=17.0.8.1
java.vendor=Eclipse Adoptium
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=es_ES
Framework arguments:  -product org.eclipse.epp.package.jee.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.jee.product

!ENTRY org.eclipse.lsp4e.debug 4 0 2023-10-27 17:28:09.517
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.lsp4e.debug [589]
  Unresolved requirement: Require-Bundle: org.eclipse.lsp4j.debug; bundle-version="[0.19.0,0.20.0)"
    -> Bundle-SymbolicName: org.eclipse.lsp4j.debug; bundle-version="0.19.0.v20221118-0359"
       org.eclipse.lsp4j.debug [591]
         Unresolved requirement: Import-Package: com.google.gson; version="[2.9.1,2.10.0)"
  Unresolved requirement: Require-Bundle: org.eclipse.lsp4j.jsonrpc; bundle-version="[0.19.0,0.20.0)"
    -> Bundle-SymbolicName: org.eclipse.lsp4j.jsonrpc; bundle-version="0.19.0.v20221118-0359"
       org.eclipse.lsp4j.jsonrpc [592]
         Unresolved requirement: Import-Package: com.google.gson; version="[2.9.1,2.10.0)"
  Unresolved requirement: Require-Bundle: org.eclipse.lsp4j.jsonrpc.debug; bundle-version="[0.19.0,0.20.0)"
    -> Bundle-SymbolicName: org.eclipse.lsp4j.jsonrpc.debug; bundle-version="0.19.0.v20221118-0359"
       org.eclipse.lsp4j.jsonrpc.debug [593]
         Unresolved requirement: Import-Package: com.google.gson; version="[2.9.1,2.10.0)"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1852)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1845)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1786)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1750)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1672)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.wildwebdeveloper 4 0 2023-10-27 17:28:09.961
!MESSAGE FrameworkEvent ERROR
!STACK 0
org.osgi.framework.BundleException: Could not resolve module: org.eclipse.wildwebdeveloper [771]
  Unresolved requirement: Require-Bundle: org.eclipse.lsp4j.jsonrpc; bundle-version="0.12.0"
    -> Bundle-SymbolicName: org.eclipse.lsp4j.jsonrpc; bundle-version="0.19.0.v20221118-0359"
       org.eclipse.lsp4j.jsonrpc [592]
         Unresolved requirement: Import-Package: com.google.gson; version="[2.9.1,2.10.0)"
  Unresolved requirement: Require-Bundle: org.eclipse.lsp4e.debug; bundle-version="0.9.0"
    -> Bundle-SymbolicName: org.eclipse.lsp4e.debug; bundle-version="0.15.0.202211181112"; singleton:="true"
       org.eclipse.lsp4e.debug [589]
         Unresolved requirement: Require-Bundle: org.eclipse.lsp4j.jsonrpc; bundle-version="[0.19.0,0.20.0)"
           -> Bundle-SymbolicName: org.eclipse.lsp4j.jsonrpc; bundle-version="0.19.0.v20221118-0359"

	at org.eclipse.osgi.container.Module.start(Module.java:463)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel$2.run(ModuleContainer.java:1852)
	at org.eclipse.osgi.internal.framework.EquinoxContainerAdaptor$1$1.execute(EquinoxContainerAdaptor.java:136)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1845)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.incStartLevel(ModuleContainer.java:1786)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.doContainerStartLevel(ModuleContainer.java:1750)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1672)
	at org.eclipse.osgi.container.ModuleContainer$ContainerStartLevel.dispatchEvent(ModuleContainer.java:1)
	at org.eclipse.osgi.framework.eventmgr.EventManager.dispatchEvent(EventManager.java:234)
	at org.eclipse.osgi.framework.eventmgr.EventManager$EventThread.run(EventManager.java:345)

!ENTRY org.eclipse.jface 2 0 2023-10-27 17:28:39.599
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-27 17:28:39.599
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.jdt.ui.navigate.open.type"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		WorkbenchHandlerServiceHandler("org.eclipse.lsp4e.symbolinworkspace"),
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:44.863
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:189)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:125)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:139)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:100)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:421)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:177)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:28:44.866
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:189)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:125)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:139)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:100)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:421)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:177)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:28:44.868
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.initialReconcile(JavaReconcilingStrategy.java:189)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.initialReconcile(CompositeReconcilingStrategy.java:125)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.initialReconcile(JavaCompositeReconcilingStrategy.java:139)
	at org.eclipse.jface.text.reconciler.MonoReconciler.initialProcess(MonoReconciler.java:100)
	at org.eclipse.jdt.internal.ui.text.JavaReconciler.initialProcess(JavaReconciler.java:421)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:177)

!ENTRY org.eclipse.egit.ui 2 0 2023-10-27 17:28:45.463
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\Francis'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:45.632
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:28:45.635
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:28:45.636
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:47.912
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 2 2023-10-27 17:28:47.914
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.ui 4 0 2023-10-27 17:28:47.915
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:561)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:209)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1325)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:132)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:94)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:91)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:158)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:78)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:207)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:50.161
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:28:50.163
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:28:50.164
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:50.240
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:28:50.242
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:51.624
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:28:51.626
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:28:51.627
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:53.905
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:28:53.907
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:28:53.908
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:56.071
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:28:56.072
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:28:56.073
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:57.330
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:28:57.332
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:28:57.333
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:58.747
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:28:58.749
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:28:58.750
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:58.849
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:28:58.851
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:28:59.063
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:28:59.064
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:28:59.065
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:02.103
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:02.126
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:02.136
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:03.746
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:03.748
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:03.749
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:04.703
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:04.704
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:04.705
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:128)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:04.730
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jface.text 4 0 2023-10-27 17:29:04.731
!MESSAGE Unexpected runtime error while computing a text hover
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.internal.core.manipulation.dom.ASTResolving.createQuickFixAST(ASTResolving.java:1052)
	at org.eclipse.jdt.internal.ui.text.correction.AssistContext.getASTRoot(AssistContext.java:131)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.getJavaAnnotationFixes(ProblemHover.java:111)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.computeCompletionProposals(ProblemHover.java:89)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover$ProblemInfo.<init>(ProblemHover.java:74)
	at org.eclipse.jdt.internal.ui.text.java.hover.ProblemHover.createAnnotationInfo(ProblemHover.java:178)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover.getHoverInfo2(AbstractAnnotationHover.java:755)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:04.777
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:04.778
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:04.779
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:08.146
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:08.147
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:08.148
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:09.831
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:09.832
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:09.833
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:11.227
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:11.228
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:11.229
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:12.578
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:12.581
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:12.583
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:14.161
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:14.162
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:14.163
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:15.761
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:15.762
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:15.763
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:16.002
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:16.003
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:16.004
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.internalGetHoverInfo(NLSStringHover.java:141)
	at org.eclipse.jdt.internal.ui.text.java.hover.NLSStringHover.getHoverInfo2(NLSStringHover.java:120)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:18.171
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:18.172
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:18.173
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:19.587
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:19.588
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:19.589
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:20.274
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:20.276
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:20.277
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:21.019
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:21.020
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:21.021
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:21.968
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:21.970
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:21.971
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:22.598
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-10-27 17:29:22.599
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-10-27 17:29:22.600
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-10-27 17:29:24.713
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
package psp.unidad01.practica111.maestra;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStreamWriter;
import java.util.*;
import java.io.PrintWriter;

public class DesviacionTipicaApp {

	private static final int PROCESOS = cantidadProcesos();
	private static final String CLASE_ESCLAVO = "psp.unidad01.practica111.EsclavoApp";
	private static final String JAR_ESCLAVO = "Esclavo.jar";
	private static final String RUTA_FICHERO_PROCESADO = "Ficheros/serieProcesado.txt";
	
	public static void main(String[] args) {
		
		if (args.length < 1) {
			
			System.err.println("Falta de parametros, Introduzca como parametro la ruta del fichero");
			return;
			
		} else {
			//Creamos la factoria de procesos
			ProcessBuilder builder = new ProcessBuilder("java", "-jar",  JAR_ESCLAVO);
			
			// Creamos los procesos
	    List<Process> procesos = new ArrayList<>();
	    for (int i = 0; i < PROCESOS; i++) {
	      try {
					procesos.add(builder.start());
				} catch (IOException e) {
					System.err.println("Error al iniciar el proceso: " + e.getMessage());
					e.printStackTrace();
				}
	    }
	    
	    //Llamamos a los metodos necesarios
	    //Quitmas las comas del fichero pasado
	    procesaFichero(args);
	    //calculamos la media de numeros dentro del fichero
	    double media = calculaMedia();
	    //contamos el numero de valores que hay dentro del fichero
	    int cantidadDeValores = cantidadValores();
	    //Pasamos los valores del fichero a una lista
	    List<Double> listaFichero = pasaFicheroLista();
	    
	    List<Process> processes = new ArrayList<>();

      int procesosSize = procesos.size();
      int itemsPerProcesos = procesosSize / PROCESOS;

      for (int i = 0; i < PROCESOS; i++) {
          List<String> dataForProcess = new ArrayList<>(listaFichero.subList(i * itemsPerProcesos, (i + 1) * itemsPerProcesos));

          ProcessBuilder hijoBuilder = new ProcessBuilder("java", "ProcesoHijo");
          Process hijo = hijoBuilder.start();

          // Obtener el ObjectOutputStream de cada proceso hijo y enviar la lista
          ObjectOutputStream objectOutputStream = new ObjectOutputStream(hijo.getOutputStream());
          objectOutputStream.writeObject(dataForProcess);
          objectOutputStream.close();

          processes.add(hijo);
      }

      // Esperar a que todos los procesos hijos terminen
      for (Process process : processes) {
          int exitCode = process.waitFor();
          System.out.println("Proceso hijo finalizado con código de salida: " + exitCode);
      }
  } catch (IOException | InterruptedException e) {
      e.printStackTrace();
  }
}
	    
	    double divideSuma = sumaTotal / cantidadDeValores;
	    
	    double raizDivision = Math.sqrt(divideSuma);
	    
	    System.out.println(raizDivision);
		}
		
		
	}
	
	/**
	 * Metodo que crea un fichero cambiando el formato del original cambiado ',' por '.' para trabajar con ellos
	 * @param args
	 */
	private static void procesaFichero(String[] args) {
		BufferedReader reader = null;
    PrintWriter writer = null;
    try {
      //Creamos los bufferes
			reader = new BufferedReader(new FileReader(args[0]));
			writer = new PrintWriter("Ficheros/serieProcesado.txt");
			//Variable que contiene cada linea leida del txt
			String linea = null;
      //Mientras que pueda leer lineas del primer txt
			while((linea = reader.readLine()) != null) {
        writer.println(linea.replace(",", "."));
			} 
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (reader != null) {
            reader.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      } if (writer != null) {
      writer.close();
      }
	  }
	}
	/**
	 * Calcula la media de los valores dentro del fichero procesado
	 * @return media
	 */
	private static double calculaMedia() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		double sumaNumeros = 0;
		double numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				sumaNumeros += Double.parseDouble(lineaProcesada);
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		double media = sumaNumeros / numeroDeValores;
		return media;
	}
	/**
	 * Cuenta el numero de valores que hay en la lista 
	 * @return cantidadValores
	 */
	private static int cantidadValores() {
	  //hacemos la media de los numeros contados en el txtProcesado
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
    //Valores necesarios para la media
		int numeroDeValores = 0;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				numeroDeValores+=1;
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return numeroDeValores;
	}
	/**
	 * Pasa el fichero procesado a lista
	 * @return listaFichero
	 */
	private static List<Double> pasaFicheroLista(){
		List<Double> listaFichero = new ArrayList<>();
	  
    BufferedReader readerProcesado = null;
    //Variable que contiene cada linea leida del txt
		String lineaProcesada = null;
	  //Mientras que pueda leer lineas del primer txt
		try {
			readerProcesado = new BufferedReader(new FileReader(RUTA_FICHERO_PROCESADO));
			while((lineaProcesada = readerProcesado.readLine()) != null) {
				listaFichero.add(Double.parseDouble(lineaProcesada));
			}
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
	    try {
        if (readerProcesado != null) {
            readerProcesado.close();
        }
      } catch (IOException e) {
        e.printStackTrace();
      }
	  }
		
		return listaFichero;
	}
	/**
	 * Calcula la cantidad de procesadores que tiene nuestro equipo, para crear procesos
	 * @return cantidadProcesos
	 */
	public static int cantidadProcesos() {
		return Runtime.getRuntime().availableProcessors();
	}
	
  public static List<List<Double>> dividirLista(List<Double> valores, int numProcesadores) {
    List<List<Double>> partes = new ArrayList<>();
    int segmento = valores.size() / numProcesadores;
    int inicio = 0;
    for (int i = 0; i < numProcesadores; i++) {
        int fin = (i == numProcesadores - 1) ? valores.size() : inicio + segmento;
        List<Double> parte = valores.subList(inicio, fin);
        partes.add(new ArrayList<>(parte));
        inicio = fin;
    }
    return partes;
  }
	
}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3882)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3124)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3419)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:344)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1272)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:294)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:286)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:199)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
